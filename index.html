<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="LOG670.TP2 : Laboratoire 2 en Langages formels et semi-formels">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
	<link rel="stylesheet" href="stylesheets/github.css">
	<script src="javascripts/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>

    <title>LOG670.TP2</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/xeph/LOG670.TP2">Voir sur GitHub</a>

          <h1 id="project_title">LOG670.TP2</h1>
          <h2 id="project_tagline">Laboratoire 2 en Langages formels et semi-formels</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/xeph/LOG670.TP2/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/xeph/LOG670.TP2/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
	  
	  <h3><a id="etats_justifies" class="anchor" href="#etats_justifies" aria-hidden="true"><span class="octicon octicon-link"></span></a>Description générale</h3>
	  
	  <p>Dans cette section, une description générale du projet sera proposé. Deux versions du système y 
	  seront décrites avec dans chacune d'elle les états, le code et les vérifications.</p>

          <p>Le projet si présent vise à faire la gestion d'un pont à l'aide de véhicules autonomes qui veulent traverser un pont à voie unique. La modélisation de
          ce système se fera à l'aide d'automates temporisés et une vérification complète du système devra être faite à l'aide de la logique CTL. Voici une image 
          permettant de mieux visualiser le problème et qui est tiré de l'énoncé du laboratoire fait par Sylvie Ratté. Le tout devra être fait avec UPPAAL.</p>

          <img src="images/description_generale.png"></img>

	  <h3><a id="partie1" class="anchor" href="#partie1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Première partie</h3>
	  
	  <h4><a id="partie1" class="anchor" href="#partie1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Modélisation des composants VAA et VAB</h4>

	  <p>Dans le modèle présent, la voiture automatisée joue un rôle très important, car ils ont une certaine autonomie à ce qui a trait à se rendre sur le pont. 
	  En effet, lorsque l’on regarde le modèle, en prenant un véhicule VAA par exemple, il est responsable de demander au contrôleur du pont s’il est en mesure de 
	  pouvoir traverser le pont. Il va donc traverser le pont s’il obtient l’autorisation du pont. De plus, en regardant le modèle, il devrait, techniquement parlant, 
	  simplement aller à l’état « End » lorsqu’il a fini de traverser le pont. Cependant, afin de pouvoir simuler un grand nombre de véhicules, il boucle quelques fois 
	  en revenant à l’état « ApprochingBridge ». De cette façon, il est plus facile de pouvoir simuler un nombre multiple de véhicules qui passent et qui repassent.</p>
	  
	  <h5><a id="partie1" class="anchor" href="#partie1" aria-hidden="true"><span class="octicon octicon-link"></span></a>VAA</h5>
	  
	  <img src="images/VAA.png"></img>
	  
	  <h5><a id="partie1" class="anchor" href="#partie1" aria-hidden="true"><span class="octicon octicon-link"></span></a>VAB</h5>
	  
	  <img src="images/VAB.png"></img>
	  
	  <h4><a id="partie1" class="anchor" href="#partie1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Explications</h4>
	  <p>La grande différence entre les deux modèles vient du fait qu’ils n’ont pas les mêmes requêtes. Le véhicule A fait des requêtes pour entrer sur le pont par l’entrée A, 
	  alors que le véhicule B par l’entrée B. Mise à part cette différence, il n’y a aucun changement au modèle.</p>

	  <p>Les états possibles pour chaque véhicule automatisé sont les suivants :</p>
	  <ul>
	  <li>Off : Le véhicule ne fonctionne pas.</li>
	  <li>ApprochingBridge : Le véhicule s’approche du pont.</li>
	  <li>IdleBridge : Le véhicule est arrivé au pont, il demande au contrôleur du pont s’il peut passer. Il vérifie périodiquement s’il peut passer sur le pont. Il faut que le véhicule ne reste pas en attente plus de 200 unités de temps.</li>
	  <li>PassingBridge : Le véhicule est sur le pont. Il faut que le véhicule ait franchi le pont sous 20 unités de temps.</li>
	  <li>PassedBridge : Le véhicule a traversé le pont.</li>
	  <li>End : Le véhicule a terminé son travail.</li>
	  </ul>

	  <p>Fonctions du modèle :</p>
	  <pre><code class="c">void resetCar() {
  canPass := false;
  requestAsked := false;
  passed++;
}

void resetRequest() {
  requestAsked := false;
  requestTime := 0;
}

void startRequest() {
  requestAsked := true;
  waitingTime := 0;
  requestTime := 0;
}
	  </code></pre>
	  
	  
	  <h4><a id="partie1" class="anchor" href="#partie1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Modélisation du composant P</h4>
	  <p>Dans la modélisation présente, le composant P n’existe pas, car le pont n’a aucune intelligence étant donné qu’il s’agit que du matériel. Étant donné 
	  qu’il n’y a pas d’intelligence sur ce composant, le pont est entièrement pris en charge par le contrôleur du pont, soit le CTRLP.</p>

	  <h4><a id="partie1" class="anchor" href="#partie1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Modélisation du composant P</h4>
	  
	  <img src="images/CTRLP.png"></img>
	  
	  <p>Le CTRLP est le cerveau du pont, car il permet d’être le policier qui dirige la circulation. Il ne fait que contrôler le flux du pont en acceptant ou 
	  en refusant les demandent pour traverser le pont. Étant donné qu’il agit comme un simple contrôleur, il ne maintient pas en mémoire les demandes des véhicules, 
	  car cette responsabilité provient des véhicules. En considérant ceci, lorsqu’il permet l’accès à un véhicule dans une direction, il ouvre la porte pour cette 
	  direction laissant passer les véhicules dans ce sens durant 20 unités de temps.</p>

	  <p>Les états possibles du CTRLP :</p>
	  <ul>
	  <li>WaitingRequest : L’état où le contrôleur attend une requête.</li>
	  <li>FirstRequest : Le contrôleur traite la première requête reçue depuis qu’il est en attente d’une requête. Il redirige tout de suite vers l’acceptation d’une requête pour commencer une traversée.</li>
	  <li>AcceptingA : Le contrôleur accepte une requête provenant d’un véhicule à l’entrée A. Il redirige tout de suite vers l’état de véhicule provenant de l’entrée A.</li>
	  <li>AcceptingB : Le contrôleur accepte une requête provenant d’un véhicule à l’entrée B. Il redirige tout de suite vers l’état de véhicule provenant de l’entrée B.</li>
	  <li>VehicleFromA : Le contrôleur prend une décision sur les requêtes selon la direction A vers B. Il offre une fenêtre de 20 unités de temps pour les véhicules provenant de A de pouvoir passer sur le pont, suivant le premier véhicule. Lorsqu’il ne reste qu’un seul véhicule et qu’il reçoit le message disant que ce véhicule a traversé, il retourne en attente de requête.</li>
	  <li>VehicleFromB : Le contrôleur prend une décision sur les requêtes selon la direction B vers A. Il offre une fenêtre de 20 unités de temps pour les véhicules provenant de B de pouvoir passer sur le pont, suivant le premier véhicule. Lorsqu’il ne reste qu’un seul véhicule et qu’il reçoit le message disant que ce véhicule a traversé, il retourne en attente de requête.</li>
	  <li>ProcessingRequestAA : Il prend la décision d’une requête A alors qu’il est en acceptation de la direction A vers B. Il accepte donc la requête du véhicule A.</li>
	  <li>ProcessingRequestBA : Il prend la décision d’une requête B alors qu’il est en acceptation de la direction A vers B. Il refuse donc la requête du véhicule B.</li>
	  <li>ProcessingRequestAB : Il prend la décision d’une requête A alors qu’il est en acceptation de la direction B vers A. Il refuse donc la requête du véhicule A.</li>
	  <li>ProcessingRequestBB : Il prend la décision d’une requête B alors qu’il est en acceptation de la direction B vers A. Il accepte donc la requête du véhicule B.</li>
	  </ul>

	  <p>Fonctions du modèle :</p>
	  <pre><code class="c">void endExitA() {
  carPassed++;
  carOnBridge--;
  lastRequest := 1;
}

void endExitB() {
  carPassed++;
  carOnBridge--;
  lastRequest := 2;
}

void entry() {
  carOnBridge++;
  carFlowTime := 0;
}
	  </code></pre>
	  
	  <h4><a id="partie1" class="anchor" href="#partie1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Assemblage</h4>
	  
	  <p>???</p>
	  
	  <h4><a id="partie1" class="anchor" href="#partie1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vérification</h4>
	  
	  <p>Procédez à la vérification formelle du modèle pour les propriétés suivantes :</p>
	  <p>P1 : Il n’y a pas de collision (i.e. deux véhicules circulants en sens inverse) sur le pont.</p>
	  <pre><code>A[] not ((vehicleB.PassingBridge && vehicleA.PassingBridge) || (vehicleB.PassingBridge && vehicleA2.PassingBridge))</code></pre>

	  <p>P2 : Un véhicule qui arrive est certain de passer sur le pont à l’issue d’une durée bornée.</p>
	  <pre><code>A[] not ((vehicleA.IdleBridge and vehicleA.waitingTime > MAXWAITTIME) || (vehicleA2.IdleBridge and vehicleA2.waitingTime > MAXWAITTIME) || (vehicleB.IdleBridge and vehicleB.waitingTime > MAXWAITTIME))</code></pre>

	  <p>Étant donné que le système est semi-vivant et qu’il est très complexe, le temps d’exécution de ces vérifications prend énormément de temps, d’où le fait de la capture d’écran pour démontrer qu’il a été possible de les valider.</p>

	  <img src="images/verif1.png"></img>
	  
	  <h3><a id="partie1" class="anchor" href="#partie1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Deuxième partie</h3>
	  
	  <h4><a id="partie1" class="anchor" href="#partie1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Modélisation du composant VA</h4>
	  
	  <img src="images/VA.png"></img>
	  
	  <p>TODO</p>
	  
	  <p>Fonctions du modèle :</p>
	  <pre><code class="c">bool sideA := true;
clock speedTimer;
clock waitingTimer;

Parameters : const id_t id, const bool prio
	  </code></pre>
	  
	  <h4><a id="partie1" class="anchor" href="#partie1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Modélisation du composant Controller</h4>
	  
	  <img src="images/C.png"></img>
	  
	  <p>TODO</p>
	  
	  <p>Fonctions du modèle :</p>
	  <pre><code class="c">id_t list[N+1];
int[0,N] len;

id_t listPrio[N+1];
int[0,N] lenPrio;

id_t passing_id;
id_t approaching_id;

void enqueue(id_t element)
{
        list[len++] = element;
}

void dequeue()
{
        int i = 0;
        len -= 1;
        while (i < len)
        {
                list[i] = list[i + 1];
                i++;
        }
        list[i] = 0;
}

void enqueuePrio(id_t element)
{
        listPrio[lenPrio++] = element;
}

void dequeuePrio()
{
        int i = 0;
        lenPrio -= 1;
        while (i < lenPrio)
        {
                listPrio[i] = listPrio[i + 1];
                i++;
        }
        listPrio[i] = 0;
}

void dequeueWithId(id_t element)
{
	if (listPrio[0] == element)
		dequeuePrio();
	else if (list[0] == element)
		dequeue();
}

bool isFrontPrio()
{
	return lenPrio > 0;
}

int queueCount()
{
	return len + lenPrio;
}

id_t front()
{
	if (isFrontPrio()) 
		return listPrio[0];
	else
		return list[0];
}

id_t tail()
{
	if (len > 0)
		return list[len - 1];
	else
		return listPrio[lenPrio - 1];
}
	  </code></pre>
	  
	  <h4><a id="partie1" class="anchor" href="#partie1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Modélisation du composant P</h4>
	  <p>Dans la modélisation présente, le composant P n’existe pas, car le pont n’a aucune intelligence étant donné qu’il s’agit que du matériel. Étant donné 
	  qu’il n’y a pas d’intelligence sur ce composant, le pont est entièrement pris en charge par le contrôleur du pont, soit le CTRLP.</p>
	  
	  <h4><a id="partie1" class="anchor" href="#partie1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Assemblage</h4>
	  
	  <p>???</p>
	  
	  <pre><code class="c">const int N = 6;
typedef int[0,N-1] id_t;

chan        approaching[N], approachingPrio[N], wait[N];
urgent chan pass[N], passed[N];
	  </code></pre>
	  
	  <h4><a id="partie1" class="anchor" href="#partie1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vérification</h4>
	  
	  <p>Procédez à la vérification formelle du modèle pour les propriétés suivantes :</p>
	  <p>P1 : Il n’y a pas de collision (i.e. deux véhicules circulants en sens inverse) sur le pont.</p>
	  <pre><code>A[] va1.Passing + va2.Passing + va3.Passing + va4.Passing + va5.Passing <= 1</code></pre>
	  <p>P2 : Un véhicule normal qui arrive est certain de passer sur le pont à l’issue d’une durée bornée.</p>
	  <pre><code>A[] not (va1.Waiting and va1.waitingTimer > 15 and va2.Waiting and va2.waitingTimer > 15 and va4.Waiting and va4.waitingTimer > 15)</code></pre>
	  <p>P3 : Un véhicule prioritaire qui arrive est certain de passer sur le pont à l’issue d’une durée bornée avant tout autre véhicule normal qui n’est pas encore entré sur le pont.</p>
	  <pre><code>A[] not (va3.Waiting and va3.waitingTimer > 5 and va5.Waiting and va5.waitingTimer > 5 and ( c.front() == 3 || c.front() == 5) )</code></pre>
	  
	  <h3><a id="etats_justifies" class="anchor" href="#etats_justifies" aria-hidden="true"><span class="octicon octicon-link"></span></a>Calendrier</h3>
	  <p>Voici la répartition des tâches du laboratoire.</p>
	  <img src="images/calendrier.png"></img>
	  
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">LOG670.TP2 maintenu par <a href="https://github.com/xeph">Marc-André Destrempes</a></p>
        <p>Publié avec <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>
  </body>
</html>
